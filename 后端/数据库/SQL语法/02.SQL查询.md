





#### SQL查询语句

- **基本查询**
  - 语句: *SELECT <查询字段> FROM <表名>*   
  - 说明: 查询字段:*代表所有, 可以可以按字段查询,多个字段用多逗号分开
  
- **条件查询**
  - 语句: *where <条件表达式1> and <条件表达式2>* 
  - 关键字:`and`表示同时满足, `or`表示满足其中之一,`not`表示“不符合该条件”的记录
  - 如果不加括号，条件运算按照`NOT`、`AND`、`OR`的优先级进行，即`NOT`优先级最高，其次是`AND`，最后是`OR`。加上括号可以改变优先级。
  
- **排序**
  - 语句: *ORDER BY <排序字段> <ASC或者DESC>*
  - 说明: ASC 从小到大, DESC 从大到小,  排序语句在条件查询后面,
  - 默认的排序规则是`ASC`：“升序”，即从小到大。`ASC`可以省略不写
  
- **分页查询**
  - 语句: *LIMIT <条数> OFFSET <开始的位置>* 开始位置从0开始
  - 说明: 分页实际上就是从结果集中“截取”出第M~N条记录, 和js中截取数组元素一样.
  - `LIMIT`总是设定为`pageSize` 
  - `OFFSET`计算公式为`pageSize * (pageIndex - 1)`
  - 分页查询需要先确定每页的数量和当前页数，然后确定`LIMIT`和`OFFSET`的值。
  - 可以简写成 **LIMIT 开始位置,条数**  
  - 先查 后排序 再进行分页
  
- **模糊查询**
  
  - 语句 *WHERE 某字段 Like 条件*
  - 其中关于条件，SQL提供了四种匹配模式：
    -  %：*表示任意0个或多个字符*。可匹配任意类型和长度的字符 
    -  _： *表示任意单个字符*。匹配单个任意字符，它常用来限制表达式的字符长度语句：
    - [ ]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。
      - 比如 SELECT * FROM [user] WHERE u_name LIKE '[张李王]三' 将找出“张三”、“李三”、“王三”（而不是“张李王三”）；
      -  如 [ ] 内有一系列字符（01234、abcde之类的）则可略写为“0-4”、“a-e” SELECT * FROM [user] WHERE u_name LIKE '老[1-9]' 将找出“老1”、“老2”、……、“老9”； 4，[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。
    - 
  
- **聚合查询**

  > 聚合函数就是计算函数,SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果

  - 语法: *SELECT 聚合函数 FROM <表名>*  
  - `COUNT(列名)`获取当前列的总数量,如果当前行的值为null,是不会统计进总数,因此如果想要获取当前的总数量, 使用 count(id)
  - `SUM(列名)` 计算当前列的总计,该列必须为数值类型
  - `AVG(列名)` 计算当前列的平均值,该列必须为数值类型
  - `MAX(列名)` 获取当前列的最大值
  - `MIN(列名)` 获取当前列的最小值
  - 使用SQL提供的聚合查询，我们可以方便地计算总数、合计值、平均值、最大值和最小值；聚合查询也可以添加`WHERE`条件。

- **连接查询**

  > 连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。

  - 语法: *SELECT 表1.数据,表2.数据 FROM <表1> INNER JOIN <表2> ON <条件...> where<....>*  
  - 示例: SELECT s.id, s.name, s.class_id, c.name class_name FROM students s INNER JOIN classes cON s.class_id = c.id
  - 先确定主表，仍然使用`FROM <表1>`的语法；
  - 再确定需要连接的表，使用`INNER JOIN <表2>`的语法；
  - 然后确定连接条件，使用`ON <条件...>`，这里的条件是`s.class_id = c.id`，表示`students`表的`class_id`列与`classes`表的`id`列相同的行需要连接；
  - 可选：加上`WHERE`子句、`ORDER BY`等子句。

  

