

## Vue的核心概念

#### 什么是MVVM模型?

- MVVM模型是一种软件架构模型,在MVVM模式中 视图层和 数据模型是没有直接的联系的,它们之间的交互是由中间层 即 Viewmodel来完成的,viewMode采用双向数据绑定的方式,将视图层和数据模型链接在一起,当数据模式中的数据发生改变时,就会同步去更新视图层
- Vue.js就是一款基于MVVM模型的框架, Vue内部实现了双向数据绑定,将数据模型和视图层链接在一起

#### Vue的双向数据绑定原理?

- Vue采用Object.defineproperty来对数据进行劫持代理,数据被读取使用的时候记录依赖（订阅者），当数据发生改变，通知对应的订阅者。
- Vue会遍历Data中的所有属性,通过Object.defineproperty来将数据转化为 get set方法, 并为每一个属性创建一个观察者,用于记录属性的依赖（订阅者）
- 当属性被使用时,get方法就会被执行,get内部就会调用观察者来记录依赖,当属性变更时,set方法就会被调用,set方法内部就会遍历观察者对象,并通知它们更新视图



- Vue通过proxy来对数据进行代理，当数据被读取，使用的时候，通过观察者模式记录下依赖（订阅），当数据被修改的时候，通知对应的订阅者。

#### Vue的虚拟DOM是什么?

**虚拟DOM：**一个用JavaScript对象来描述真实DOM的对象。直接操作真实的DOM开销大，所以使用虚拟DOM来替代

**渲染函数：**返回虚拟DOM的函数。

模板的生命周期：

- 编译：Vue将模板编译成渲染函数（一个返回虚拟DOM的函数）
- 挂载：运行的时候，渲染器会调用渲染函数，遍历返回得虚拟DOM，基于虚拟DOM创建真实得DOM节点。在挂载的过程中还会去追踪其中所用到的所有响应式依赖。
- 修补：当依赖发生变化后，副作用函数会从新执行，创建一个新的虚拟DOM。然后渲染器会遍历这个新的DOM，并将它和之前的旧的DOM对象进行比较，最后将变化点应用到真实DOM上。











#### Vue编译魔板的原理是什么?

- 把魔板编程成redder函数,然后再执行reder函数,把魔板转为虚拟Dom

#### Vue中的key有什么作用?

- 给节点绑定一个标识,让虚拟dom更加高效更新

#### Vue中DOM的异步更新策略以及nextTick机制

#### proxy和Object.defineProperty 的优势对比?

- peoxy能监听整个对象,而它只能监听属性



#### 什么是SPA单页面应用?

- SPA单页面应用,指的是, 在首次访问网站时就会将整个应用需要的代码都加载进来,利用前端路由替代后端路由来进行页面之间的跳转,这样就可以让网站在不进行跳转加载就能完成页面之间的跳转
- SPA单页面用应用的优点很明显,由于不需要后端路由来进行页面之间的跳转,大大提高了用户的体验,同时也减轻了服务器的压力
- 缺点在于,由于在首次访问网站的时候就需要将整个应用的代码都下来下来,首次加载耗时非常大,
- 可以通过Vue路由的懒加载和图片懒加载等技术来减少首次加载耗时多的问题



#### Vue基础

- computed 和watch的区别?
  - computed是计算属性,依赖于它属性的响应式,并且计算属性是有缓存的,只有当它依赖的属性发生改变时才会从新去执行求值.计算属性的作用是用来替代魔板上的逻辑代码.因为在魔板上写太多的逻辑代码会让组件难以维护.
  - watch 是监听器, 监听属性的变化.当属性发生变化时就会执行
- Vue过滤器 
  - Vue中的过滤器主要是用来格式化文本的, 过滤器分为全局的过滤器和局部过滤器, 全局过滤器通过 Vue.
- Vue混入
  - 作用向组件内部混入一些复用性的功能 ,混入又分为全局混入和局部混入, 全局通过 Vue.mixin来混入, 局部通过组件的实际 的mixins来混入
- V-mode的原理是什么?
  - v-mode是用来对表单元素进行双向绑定的,它是一个语法题,它内部是采用了v-bind和v-on来实现的,
  - 在作用于input标签时,会先通过v-bind来绑定input标签的value值, 然后通过v-on来绑定input的输入事件,当用户输入内容时,事件就会被触发,将输入的内容和vlaue值进行同步, 从而达成双向绑定
- v-if和v-show有什么区别?
  - v-if是条件渲染,会根据条件来判断是渲染还是销毁组件,并且它是惰性的,当它的初始值为假时,是不会渲染组件的,
  - 而v-show则是一定会渲染组件,只是根据条件来判断是显示还是隐藏组件
  - 如何需要非常频繁的切换组件,使用v-show 如果是很少改变,使用v-if
- 如何动态绑定 class 和 style?
  - 通过v-bind来绑定,可以使用对象的语法也可以使用数组的语法
  - 数组的语法可以使用三元表达式
- computed 和watch的区别是什么?
  - computed是计算属性,它依赖于它属性的相适应,并且它是有缓存的只要当它的属性发生改变时才会从新进行求值,并且计算属性中不能使用异步方法,computed的设计初衷时为了将魔板上过于复杂的逻辑代码替换成计算属性
  - 而watch则是监听器,用来监听属性的变更,在watch中可以进行异步操作
  - 在项目中经常使用watch来监听props中的属性,只有props中的数据传入时,才渲染组件
- 谈谈你对keep-alive的理解?
  - keep是Vue内置的一个组件,主要作用是用来缓存组件,避免组件被销毁 通过 include来指定缓存的组件,通过exclude 来指定不缓存的组件,并且 exclude必include拥有更改的优先级
  - 在使用keep-alice来缓存组件的时候,也会有两个钩子函数会被调用, 缓存组件激活时的钩子函数,和缓存组件进入缓存转态时的钩子函数
- v-for和v-if的优先级?
  - v-for比v-if拥有更改的优先级



#### Vue的生命周期

- 谈谈你对Vue生命周期的理解
  - vue的生命周期分为八个阶段 实例创建前后 DOM挂载前后  数据更新前后 和 实例销毁前后
  - 实例创建前 ，只是通过new Vue来创建了一个实例。这个时候实例中只有从Vue构造函数中继承的属性和方法。
  - 实例创建后 ，这个时候实例才是一个完整的实例。实例中的我们定义的属性或者方法都可以调用了，一般在这个阶段发送异步请求获取数据
  - DOM更新前，在这个阶段只想把模板解析成虚拟DOM，还没有把DOM挂载到页面中
  - DOM更新后，在这个阶段，DOM才挂载到页面中
  - 数据更新前 ， 这个阶段data中的数据已经更新，但是还没有和页面进行同步，页面的内容还是旧的
  - 数据更新后，  这个阶段 才完成数据和页面的同步，并把DOM挂载到页面中
  - 实现销毁之前，在这个阶段 实例还是完整的实例没进行销毁，一般在这个钩子中关闭定时器
  - 实例销毁后， 到这个阶段实例已经完全被



#### Vue组件

- 在Vue中怎么使用组件?
  - 创建一个.vue文件,文件中编写组件的样式及逻辑 然后再需要使用的地方通过 import 导入,并挂载到实例的components中
  - 组件注册分全局注册和局部注册, 全局注册通过Vue.component()来进行全局注册, 局部注册 在组件实例中通过components属性来进行注册
- 父子组件的实例怎么获取?
  - 父组件获取子组件实例  通过 ref 来标识子组件,然后通过 this.$refs 来获取子组件的实例
  - 子组件获取父组件的实例 通过 this.$parent来获取父组件实例
- 组件中的data为什么必须是一个函数?
  - 因为JavaScript的对象是存储在内存堆中的,在内存栈中只是保存了对象的引用地址,我们不能直接操作对象,只能操作对象的引入
  - 如果组件中的data不是一个函数返回一个新的对象,那么在进行组件复用的时候,所有的组件中的data都会指向于同一个对象,那么在操作组件的时候,就会影响到所有的复用组件
- 怎么理解Vue组件的单向数据流?
  - props的数据是单向向下绑定的,父组件props的属性发生变化会更新子组件的props,但是反过来不行.是为了防止子组件意外改变父组件的转态,导致出现问题难以排查问题
- 插槽有哪些?怎么使用?
  - 插槽分为 匿名插件 和 具名插件
- 父组件怎么监听子组件的生命周期?
  - 通过 @hook 来监听子组件的生命周期
- 父子组件的生命周期执行顺序?
  - 父子组件的生命执行顺序 遵循  由外到内再由内到外的规则
  - 在渲染阶段, 首先会先创建父组件的实例, 然后再Dom挂载之前 创建子组件的实例并挂子组件挂载到页面中,最后才挂载父组件
  - 在数据更新阶段, 先

### Vue组件通讯:

- Vue组件通讯分为父子组件通讯和非父子组件通讯:
- 父子组件通讯:
  - 通过自定义事件和props:
    - 通过props 和自定义事件来完成, 父组件通过props 来向子组件传递数据, 子组件通过自定义事件来向父组件传递数据
  - 通过Ref对象:
    - 在父组件中也可以通过 ref 来标识子组件,然后通过 $refs 来获取到子组件的实例, 子组件通过 $paren 来获取到父组件的实例
- 非父子组件通讯:
  - Vuex:
  - 通过事件总线 EventBus 来实现
    - Vue.prototype .$bus = new Vue()
    - 在main.js中的vue原型对象中挂载一个vue实例, 就可以在全局中使用, 通过this.$bus.emit来发送事件,通过this.$bus.$on来监听事件



#### Vue遇到的问题

- 动态使用本地资源的问题
  - 需要通过 require()的方式来导入使用

