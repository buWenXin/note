

- **JavaScript有哪些数据类型?**
    - 在JavaScript中一共有七种数据类型,可以分为两类 即 基础数据类型 和引用数据类型
    - 基础数据类型有  null undefined string  number boolear
    - 引用数据类型:  object
- **基本数据类型和引用数据类型有什么区别?**
- 基本数据类型存储于内存栈中,我们可以直接操作他们,
    - 而引用数据类型存储于内存堆中,在作为变量使用时,只是在内存栈中存储数据的引用地址,所以我们不能直接操作引用数据类型
    - 两者在作为函数的参数进行传递时,基本数据类型传入的是数据的副本,引用数据类型传入的时数据的引用地址,因此原数据的更改,或者在函数内对引用数据进行更改都会影响到元数据
- **判断数据类型的方法有哪些?**

    - 利用typeof可以判断数据类型, 但是在判断 null array 和object 的时候都会返回 object,无法进一步判断他们的具体数据类型
    - 想要判断它们具体的数据类型,最好的办法就是 调用object原生的toString方法来进行判断 ,这个方法会返回
    - 在任何值上调用 Object 原生的 toString() 方法，都会返回一个 [object NativeConstructorName] 格式的字符串。每个类在内部都有一个 [[Class]] 属性，这个属性中就指定了上述字符串中的构造函数名
- **js中声明变量有几种方式?它们有什么区别?**
- 在JavaScript中声明变量有三种方式 var let const ,其中let 和const 都是es6中新引入的, 
    - var 声明的变量是有变量提升并且是函数作用域: let const 声明的变量就没有变量提升,且它们都是块级作用域
    - 因为没有变量提升 ,所以 let 和const 不能重复声明变量; cosnt 声明的变量是产量 不能修改 并且初始化时必须赋值
- **什么是变量提升和函数提升?**
- 变量提升,通过var 定义的变量,在定义语句之前就可以访问到,不过值为undefined,要想真的使用到它的值,还得在定义语句后
    - 函数提升,通过function声明的函数,在函数声明之前就可以直接调用
    - 变量提升和函数提升都是因为*执行上下文*而产生的,因为执行上下文都会有一个预处理的
- **什么是执行上下文和执行上下文栈?**
    - 执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。执行上下文分为 全局执行上下文 和 函数执行上下文
    - **全局执行上下文:** 
        - 在执行代码之前 ,会先将浏览器的window对象确定为全局执行上下文对象, 并对全局数据进行预处理 
        - var 定义的全局变量赋值为 undefined ,并将其添加为window的属性,
        - function声明的全局函数赋值,并将其添加为window的方法,
        - this赋值给window
        - 将window对象推入到执行栈中执行 
    - **函数执行上下文:**
        - 在调用函数,准备执行函数体之前,创建对应的函数执行上下文对象,并对函数内部数据进行预处理
            - 把函数的 形参 赋值给 实参,并添加为函数执行上下文对象的属性
            - var 定义的局部变量 赋值为 undefined,添加为函数执行上下文对象的属性
            - function声明的函数赋值,添加到执行上下文对象中
            - this赋值给函数执行上下文对象
            - 最后才开始执行函数体代码
    - 当然,全局执行上下文对象和函数执行上下文对象,都是不是真的对象,就如同上面说的一样,执行上下文是一种抽象的概念,把它描述成对象只是为了更好的理解
    - 但无论在全局还是函数内部,在代码执行之前都会先创建一个对象用于存储属性和方法及this
    - 函数在执行前都会先在栈内存中开辟一块内存,用于存储数据
- **执行栈**
    - 栈是一种*后进先出*的数据结构 ,js引擎在执行代码前,会先创建一个执行栈,来存储和管理所有的执行上下文对象
    - 全局执行上下文对象(window)确定后,将其添加到栈中
    - 函数执行上下文对象,在创建后也会添加到栈中
- **原型与原型链**
    - 原型是一个对象
    - **函数的prototype属性**   (显示原型)
        - 函数也是一个对象
        - 每个函数都有有一个 prototype 属性,它默认指向一个Object空对象(这个对象就是函数的原型对象)
        - 在函数的原型对象中 也有一个 constructor属性,指向函数对象本身
        - 函数的prototype属性,在定义函数时自动添加
    - 一般使用函数的原型添加方法,实现构造函数
    - **实例对象的proto属性**    (隐式原型)
        - 每个实例对象都有一个proto属性,默认指向它父构造函数的原型对象  即对象的隐式原型指向它构造函数的显示原型对象
        - 实例对象的隐式原型指向它父构造函数的显示原型属性
    - **原型链:**
        - 访问一个对象的属性时,先在自身查找,如果找到就返回,如果没有找到就沿着隐式原型链继续查找,直到







- 说一下同步和异步区别?
    - 同步是阻塞模式,异步是非阻塞模式
    - 同步是指进程在执行某些请求时,如果请求需要一段时间才能返回信息,那么进程会一直处于等待状态,直到有信息返回时,进程才会继续执行,这样就造成了堵塞
    - 异步是指进程不不需要等待,继续执行其他操作 ,当请求信息返回时, 系统才会通知进程进行处理
- 什么是事件? 如何阻止事件冒泡?
    - 事件是用于监听浏览器操作行为,浏览器触发动作时会被事件系统铺抓到,事件系统就会执行相应的回调函数
    - 在vue中,使用vue提供的事件修饰符 .stop 来阻止事件冒泡
- 什么是跨越请求?怎么解决?
    - 跨越请求 就是 跨越资源共享 ,但是浏览器出于安全考虑,设置了 同源策略 来限制JavaScript发送跨越请求
    - 同源策略 指的 域名 协议 端口 均相同
    - 解决跨越 可以使用 jsonp 在开发阶段 也可以配置本地代理 但是它们都存在一定的缺陷 ,最好的办法还是后端设置跨越
    - 
- JSON格式是什么?
    - JSON的一种轻量级的数据交换格式 它是JavaScript的一个子集,它的优点在于结构简单,易于读写,且占用带宽少,所以经常用作于数据的交换
- JavaScript的基本规范?
    - 不要在同一行声明多个变量
    - 函数应该有返回值
    - 使用 绝对等于 或者 绝对不等于来判断 数组 和布尔值
    - for语句和if语句必须带打垮好
- 是否设置过通用组件?
    - 有的,在项目中
- 什么闭包?为什么要使用它?
    - 闭包是由于函数嵌套,并且内部函数调用外城函数的数据,所造成的
    - 当我们在内层函数通过作用域链使用外城函数的数据的时候,js会创建一个空的对象,用于存储我们引用的数据
    - 使用闭包可以访问外城函数的数据,并且能延长数据的生命周期
    - 闭包是一个对象,用于
    - 但是闭包的缺点也很明显,使用闭包不规范很容易造成内存泄漏
    - 当引用的数据不在需要使用时 将其赋值为null 浏览器的垃圾回收系统 会自动回收它
- 谈谈你对thsi的理解?
    - this.是JavaScript的一个关键字 在全局作用域中this指向windo ,而且在函数作用域中 ,thsi指向它函数的直接调用者
- 创建对象的方式有哪些?
    - 通过构造函数创建 ,使用对象字面量创建 工厂模式创建
- new操作符具体做了什么?
    - 创建一个空对象 ,将this指向它 同时继承构造函数的原型
    - 将构造函数的属性和方法添加到对象中
    - 隐式返回this





- 同步和异步的区别?
    - 同步是阻塞模式 异步是非阻塞模式
    - 同步就是指进程在发生某些请求时,如果这个请求需要一段时间才能返回新 ,那么进程就会一种处于等待状态,直到有信息返回进程才会继续执行 ,这样就造成了堵塞
    - 异步是指进程不需要一直等待,而是继续执行其他操作, 当有信息返回时,系统才会通知进程处理
- 什么是跨越请求? 怎么解决?
    - 跨越请求 就是跨越资源共享 ,但是浏览器出于安全考虑 ,设置了 同源策略来限制JavaScript发生跨越请求
    - 解决跨越请求 可以使用 jsonp的方式来发生请求 ,也可以设置本地代理,但是这些方法都存在一定的缺陷 ,最好还是后端进行跨越配置
- 事件什么 如何阻止事件冒泡?
    - 事件用于监听浏览器的操作行为 ,浏览器触发动作时会被事件系统所铺抓 ,事件系统就会执行相应的回调函数
    - 在vue中 ,使用vue提供的事件修饰符 .stop 来阻止事件冒泡
- 什么是闭包?为什么要使用它?
    - 闭包是由于函数嵌套 内层函数引用了外层函数的数据所造成的
    - 使用闭包可以延长引用数据的生命周期
    - 但是如果使用不规范就有可能造成内存泄漏
- 创建对象的方式有哪些?
    - 可以使用 构造函数模式 原型模式 工厂 模式和对象字面量模式
- JSOn 
- this是JavaScript的中一个关键字 在全局作用域中this执行window对象 ,在函数作用域中 this始终指向它函数的直接调用者
- js中的内存空间分为 栈和堆 栈存储变量 丢存储object对象
- 栈是一个*后进先出*的数据结构







- 执行上下文与执行上下文栈
- 作用域
- 闭包
    - 闭包是一个对象
        - 闭包是由于函数嵌套,内层的函数引用了外层函数的数据,所产生的
        - 闭包的优点在于 可以延长引用数据的生命周期,便于我们使用,但缺点也很明显,使用不规范容易造成内存泄漏
- 原型与原型链
    - 原型:
        - 原型是一个对象
        - 每一个函数都会有一个 prototype 属性,默认指向一个空的object对象,这个对象就是原型对象
        - 每一个实例化对象也会有一个 proto 属性,默认指向它的父构造函数的原型对象
        - 实例化对象的隐式原型指向它父构造函数的显示原型对象
        - 函数也是对象,所有函数也拥有 proto 属性,也就是说函数同时拥有显示原型和隐式原型,函数的显示原型指向一个空原型对象,它的隐式原型指向它构造函数的原型对象
        - 所有的对象都是基于Object的构造函数创建的,所有对象的隐式原型指向Object构造函数的显示原型对象
        - function 的构造函数 Function 也是拥有显示原型和隐式原型属性的,但是它的显示原型和隐式原型都执行同一个原型对象
        - 这就说明了Function也是一个实例,并且它是通过自己 new自己实现的
    - 原型链:
        - 原型链也叫隐式原型链
            - 作用是用于查找对象的属性或者方法
            - 当一个对象在查询属性的时候,如果在自中没有找到,就会沿着隐式原型链继续查找,直到原型链的尽头,如果还是没有找到,就返回undefined
            - 原型链的尽头是Object构造函数,它的proto属性的值是null
            - 
- 原型与原型链
    - 原型:    prototype(显示原型)  proto(隐式原型)
        - 原型是对象
        - 每一个函数都有一个 prototype 属性,这个属性指向一个空的object对象,这个对象就是原型对象
        - 每一个实例对象,都有一个 proto 属性,指向它父构造函数的原型对象
        - 函数也是一个实例对象,是new Function产生的,所以函数的proto属性指向构造函数的原型对象
        - 对象都是通过new Object产生的,所有函数的原型对象,指向Object构造函数
- SPA单页面的理解,它的优缺点是什么?
- v-if和v-shouw的区别?
    - v-if真正的条件渲染, 但是它也是惰性的,如果它的初始值为假时,是不会渲染页面的,而v-shou则是一定会渲染页面,只是通过判断值来绝对是将内容隐藏还是显示而已
- 



































































