

#### Vue的核心概念

- 什么是MVVM模型?
    - MVVM模型是一种软件架构模型,在MVVM模式中 视图层和 数据模型是没有直接的联系的,它们之间的交互是由中间层 即 Viewmodel来完成的,viewMode采用双向数据绑定的方式,将视图层和数据模型链接在一起,当数据模式中的数据发生改变时,就会同步去更新视图层
    - Vue.js就是一款基于MVVM模型的框架, Vue内部实现了双向数据绑定,将数据模型和视图层链接在一起
- Vue的双向数据绑定原理?
    - Vue采用Object.defineproperty来对数据进行劫持代理,当数据发改变时, 通过 发布订阅者模式去通知视图进行改变
    - Vue会遍历Data中的所有属性,通过Object.defineproperty来将数据转化为 get set方法, 并为每一个属性创建一个观察者,用于记录属性的依赖
    - 当属性被使用时,get方法就会被执行,get内部就会调用观察者来记录依赖,当属性变更时,set方法就会被调用,set方法内部就会遍历观察者对象,并通知它们更新视图
- 什么是SPA单页面应用?
    - SPA单页面应用,指的是, 在首次访问网站时就会将整个应用需要的代码都加载进来,利用前端路由替代后端路由来进行页面之间的跳转,这样就可以让网站在不进行跳转加载就能完成页面之间的跳转
    - SPA单页面用应用的优点很明显,由于不需要后端路由来进行页面之间的跳转,大大提高了用户的体验,同时也减轻了服务器的压力
    - 缺点在于,由于在首次访问网站的时候就需要将整个应用的代码都下来下来,首次加载耗时非常大,
    - 可以通过Vue路由的懒加载和图片懒加载等技术来减少首次加载耗时多的问题
- Vue的虚拟DOM是什么?
    - Vue中的虚拟Dom是用JavaScript对象来对真实Dom的模拟,
- Vue编译魔板的原理是什么?
    - 把魔板编程成redder函数,然后再执行reder函数,把魔板转为虚拟Dom
- Vue中的key有什么作用?
    - 给节点绑定一个标识,让虚拟dom更加高效更新
- Vue中DOM的异步更新策略以及nextTick机制
    - 
- 直接给一个数组项赋值,Vue能检测到数据变化吗?
    - 不能,由于JavaScript的限制,直接通过索引来修改数组项,或者更改数组的长度,Vue都不能检测到变化, 可以使用vue.set()来解决
- proxy和Object.defineProperty 的优势对比?
    - peoxy能监听整个对象,而它只能监听属性



#### Vue基础

- computed 和watch的区别?
    - computed是计算属性,依赖于它属性的响应式,并且计算属性是有缓存的,只有当它依赖的属性发生改变时才会从新去执行求值.计算属性的作用是用来替代魔板上的逻辑代码.因为在魔板上写太多的逻辑代码会让组件难以维护.
    - watch 是监听器, 监听属性的变化.当属性发生变化时就会执行
- Vue过滤器 
    - Vue中的过滤器主要是用来格式化文本的, 过滤器分为全局的过滤器和局部过滤器, 全局过滤器通过 Vue.
- Vue混入
    - 作用向组件内部混入一些复用性的功能 ,混入又分为全局混入和局部混入, 全局通过 Vue.mixin来混入, 局部通过组件的实际 的mixins来混入
- V-mode的原理是什么?
    - v-mode是用来对表单元素进行双向绑定的,它是一个语法题,它内部是采用了v-bind和v-on来实现的,
    - 在作用于input标签时,会先通过v-bind来绑定input标签的value值, 然后通过v-on来绑定input的输入事件,当用户输入内容时,事件就会被触发,将输入的内容和vlaue值进行同步, 从而达成双向绑定
- v-if和v-show有什么区别?
    - v-if是条件渲染,会根据条件来判断是渲染还是销毁组件,并且它是惰性的,当它的初始值为假时,是不会渲染组件的,
    - 而v-show则是一定会渲染组件,只是根据条件来判断是显示还是隐藏组件
    - 如何需要非常频繁的切换组件,使用v-show 如果是很少改变,使用v-if
- 如何动态绑定 class 和 style?
    - 通过v-bind来绑定,可以使用对象的语法也可以使用数组的语法
    - 数组的语法可以使用三元表达式
- computed 和watch的区别是什么?
    - computed是计算属性,它依赖于它属性的相适应,并且它是有缓存的只要当它的属性发生改变时才会从新进行求值,并且计算属性中不能使用异步方法,computed的设计初衷时为了将魔板上过于复杂的逻辑代码替换成计算属性
    - 而watch则是监听器,用来监听属性的变更,在watch中可以进行异步操作
    - 在项目中经常使用watch来监听props中的属性,只有props中的数据传入时,才渲染组件
- 谈谈你对keep-alive的理解?
    - keep是Vue内置的一个组件,主要作用是用来缓存组件,避免组件被销毁 通过 include来指定缓存的组件,通过exclude 来指定不缓存的组件,并且 exclude必include拥有更改的优先级
    - 在使用keep-alice来缓存组件的时候,也会有两个钩子函数会被调用, 缓存组件激活时的钩子函数,和缓存组件进入缓存转态时的钩子函数
- Vue的指令有哪些?
    - v-bind v-on v-mode 
- Vue.use()
    - 用来注册注册
- Vue.delete()
    - 响应式的删除数组或者对象中的属性
- Vue中常用的修饰符
- v-for和v-if的优先级?
    - v-for比v-if拥有更改的优先级



#### Vue的生命周期

- 谈谈你对Vue生命周期的理解
    - vue的生命周期分为八个阶段 实例创建前后 DOM挂载前后  数据更新前后 和 实例销毁前后
    - 实例创建前 ，只是通过new Vue来创建了一个实例。这个时候实例中只有从Vue构造函数中继承的属性和方法。
    - 实例创建后 ，这个时候实例才是一个完整的实例。实例中的我们定义的属性或者方法都可以调用了，一般在这个阶段发送异步请求获取数据
    - DOM更新前，在这个阶段只想把模板解析成虚拟DOM，还没有把DOM挂载到页面中
    - DOM更新后，在这个阶段，DOM才挂载到页面中
    - 数据更新前 ， 这个阶段data中的数据已经更新，但是还没有和页面进行同步，页面的内容还是旧的
    - 数据更新后，  这个阶段 才完成数据和页面的同步，并把DOM挂载到页面中
    - 实现销毁之前，在这个阶段 实例还是完整的实例没进行销毁，一般在这个钩子中关闭定时器
    - 实例销毁后， 到这个阶段实例已经完全被



#### Vue组件

- 在Vue中怎么使用组件?
    - 创建一个.vue文件,文件中编写组件的样式及逻辑 然后再需要使用的地方通过 import 导入,并挂载到实例的components中
    - 组件注册分全局注册和局部注册, 全局注册通过Vue.component()来进行全局注册, 局部注册 在组件实例中通过components属性来进行注册
- 父子组件的实例怎么获取?
    - 父组件获取子组件实例  通过 ref 来标识子组件,然后通过 this.$refs 来获取子组件的实例
    - 子组件获取父组件的实例 通过 this.$parent来获取父组件实例
- 组件中的data为什么必须是一个函数?
    - 因为JavaScript的对象是存储在内存堆中的,在内存栈中只是保存了对象的引用地址,我们不能直接操作对象,只能操作对象的引入
    - 如果组件中的data不是一个函数返回一个新的对象,那么在进行组件复用的时候,所有的组件中的data都会指向于同一个对象,那么在操作组件的时候,就会影响到所有的复用组件
- 怎么理解Vue组件的单向数据流?
    - props的数据是单向向下绑定的,父组件props的属性发生变化会更新子组件的props,但是反过来不行.是为了防止子组件意外改变父组件的转态,导致出现问题难以排查问题
- 插槽有哪些?怎么使用?
    - 插槽分为 匿名插件 和 具名插件
- 父组件怎么监听子组件的生命周期?
    - 通过 @hook 来监听子组件的生命周期
- 父子组件的生命周期执行顺序?
    - 父子组件的生命执行顺序 遵循  由外到内再由内到外的规则
    - 在渲染阶段, 首先会先创建父组件的实例, 然后再Dom挂载之前 创建子组件的实例并挂子组件挂载到页面中,最后才挂载父组件
    - 在数据更新阶段, 先

### Vue组件通讯:

- Vue组件通讯分为父子组件通讯和非父子组件通讯:
- 父子组件通讯:
  - 通过自定义事件和props:
    - 通过props 和自定义事件来完成, 父组件通过props 来向子组件传递数据, 子组件通过自定义事件来向父组件传递数据
  - 通过Ref对象:
    - 在父组件中也可以通过 ref 来标识子组件,然后通过 $refs 来获取到子组件的实例, 子组件通过 $paren 来获取到父组件的实例
- 非父子组件通讯:
  - Vuex:
  - 通过事件总线 EventBus 来实现
    - Vue.prototype .$bus = new Vue()
    - 在main.js中的vue原型对象中挂载一个vue实例, 就可以在全局中使用, 通过this.$bus.emit来发送事件,通过this.$bus.$on来监听事件



#### Vue-router

- 在项目中使用Vue-router
    - 先创建一个文件,在文件中导入Vue和Vue-router,然后使用Vue.use()来注册Vue-router ,然后通过New VueROuter 来创建一个router实例,配置路由映射和路由模式,最后将路由实例导出 并在挂载到全局的vue实例中
- Vue路由有哪些属性?
    - routes   配置映射关系
    - mode    设置路由模式
    - base    设置基路径
- 路由的懒加载
    - Vue路由的懒加载是通过 Vue的异步组件结构webpack的代码分割来实现的,在项目中通过 ()=> import("")的方式来使用路由懒加载
- 配置路由映射
    - 在路由实例中的routes中 以对象的方式配置路由映射,path 配置路由路径 component配置路由映射的组件
- 怎么配置路由的重定向?
    - 在配置路由映射时, 通过 redirect来将重定向到想要的页面
- 路由跳转的方式?
    - 通过路由实例进行跳转和内置的组件 router-link 来进行跳转
    - 通过 $router.push()来进行跳转 或者 通过 内置的组件 router-link 来跳转
- router 和 route的区别?
    - router是路由实例,可以通过路由的实例来进行路由跳转
    - route 是路由对象,里面存放这路径 params query参数
- 路由对象中有哪些属性?
    - 有路径 params query ,有当前的路由路径和params,query参数
- 路由的模式有几种?
    - 路由的模式有三种 hahs模式 history模式 Abstract模式, hash模式和history都是基于浏览器的api来实现的, hash模式会在ulr上有一个#号,而history模式则没有,不过history模式只兼容Ie10及以上,并且在使用的时候需要后端配合
- Vue router 有哪些组件?
    - 有rook-link 和router view
- Vue路由组件传递参数的方法有哪些?
    - 可以通过动态路由的方式传递数据,然后通过路由对象的params来获取传入的参数,以及在进行路由跳转的时候直接携带参数,然后通过路由对象的query来获取
- 路由的导航守卫有哪些?
    - 路由的导航守卫分为三种 全局的导航守卫 路由独享的导航守卫以及组件的导航守卫,导航守卫的主要作用是用来进行路由拦截
    - 在进行路由跳转的时候,判断用户是否已经登录,如果已经登录就进行跳转,如果用户没有登录则跳转到登录页面
    - 可以在全局的前置钩子中,判断用户登录转态,也可以在组件的beforeRouteEnter中判断
    - 全局导航守卫  beforeEach 全局前置守卫   beforeResolve 全局解析守卫 以及afterEach 全局后置守卫
    - 组件守卫 beforeRouterEnter 进入组件之前   beforeRouteUpdate 路由更新之前   beforeRouteLeave 离开组件之前
    - 路由的守卫都接受三个参数, to 即将要进入的路由对象 from 当前要离开的路由对象 next() 调用该方法来进入到下一个导航钩子,如果直接调用就表示进入到下一个导航钩子中,如果传入一个false 则中断当前导航, 如果 传入一个路由则表示跳转到指定的页面
- Vue路由的原理?
    - 







#### Vuex

- 怎么使用Vuex?
    - 通过Vue的脚手架配置Vuex插件,如果在store中创建一个index文件,在index中导入Vuex和Vue实例,并通过Vue.use来注册Vuex,然后通过New Vue.store来创建Vuex实例,并将实例导出挂载到vue实例中使用
- Vuex的使用
    - 使用数据  通过this.$store.state来使用数据
    - 修改数据  在mutations中定义修改数据的事件,然后通过this.$store.commit来提交事件
- Vuex有哪些属性?
    - Vuex中五个属性
    - state
        - 数据仓库,在这里定义属性, 需要注意只要在state进行初始化的属性才会有响应式.
    - getters
        - 和Vue组件的计算属性一样,都是有缓存的,只有当它依赖的属性发生改变时,才会从新计算
        - 使用  可以通过属性的方式使用 也可以通过调用方法的方式去使用,使用方法的方式使用时,可以传入参数
        - 在组件中通过this.$store.getter来使用
    - mutations
        - 定义事件来对state中的数据进行修改,在这里只能执行同步任务
    - actives
        - 和mutation类型,不同的是,actives是提交mutations事件来修改数据而不是直接修改数据,并且active可以执行异步任务,而mutations只能执行同步任务
        - 并且在active中也可以返回一个promise对象,然后再提交事件后面跟着then来知道什么时候提交成功
        - 使用  actives中接受store来作为第一个参数,所有可以通过 store.commit来提交mutations事件
        - 在组件中 通过 this.$store.dispatch 来提交actives事件
    - gettets和mutations都接受state来作为第一次参数,而actives则接受store来作为第一个参数
    - 可以通过 ...扩展运算符来将 getters 中的 计算属性 或者 actives中的方法映射到组件中进行使用 getters映射到computed中,actives映射到methods中
    - Vuex在页面刷新后数据丢失问题
        - 由于Vuex中的数据是存储在内存中的, 当页面刷新时 Vuex中的数据就会丢人, 通过监听页面的刷新事件,在页面刷新前将Vuex中的数据转为JSON数据格式,并存储到sessionStorage中,
        - 当页面刷新完成后,从新请求Vuex中的数据,但是请求数据需要时间,所有可以先利用sessionStorage中的数据进行展示,等待数据请求成功后再进行更新



#### Vue遇到的问题

- 动态使用本地资源的问题
    - 需要通过 require()的方式来导入使用

