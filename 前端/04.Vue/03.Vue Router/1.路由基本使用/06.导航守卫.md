# 导航守卫

> Vue-Router提供了*路由导航守卫主*要用来在路由跳转的时候，可以取消跳转或者是重定向路由。

路由守卫分为三种：

- 全局守卫： 全局前置守卫、全局解析守卫、全局后置钩子
- 路由独享守卫：
- 组件路由守卫：
- **执行顺序：** 全局前置守卫 ==》路由独享守卫 ==》 全局解析守卫 ==》全局后置钩子
- 注意：钩子和守卫不同的是，钩子不会接受 `next` 函数也不会改变导航本身，因为在这里路由已经跳转完成。

## 全局路由守卫

### 全局路由前置守卫：

> 在路由跳转之前调用：在全局的前置钩子中进行登录转态判断，如果用户没有登录跳转到登录页面。如果已经登录，则不再跳转登录页面。
>

```ts
/**
 * 全局导航前置守卫
 *  to:将要进入的路由
 *  from:当前导航正要离开的路由
 */
router.beforeEach((to: RouteLocationNormalized, from: RouteLocationNormalized) => {
    return false; //取消导航
    return "/login";//跳转到该地址
    return  true; //返回true，或者没有返回值，则表示正常，调用下一个钩子函数
})
```

每个路由守卫都可以接受三个参数：

- `to`：将要进入的路由对象
- `from`：当前导航正要离开的路由对象
- `next`（**可选参数**）：一个方法，如果使用了这个参数就必须调用，不然路由无法跳转。**不推荐使用**

每个路由守卫都可以返回这三种返回值:

- 返回`false`：则表示*取消当前导航*。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。
- 返回`字符串`：则表示跳转到该字符串的路由地址，就像调用`router.push()`一样。

- **没有返回值或者返回true：** *没有返回值*或者返回 `true`，**则导航是有效的**，并调用下一个导航守卫

### 全局路由解析守卫

> 路由确定要跳转，开始解析要跳转的路由对象。
>
> 它在 **每次导航**时都会触发，但是确保在导航被确认之前，**同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用**。这里有一个例子，确保用户可以访问[自定义 meta](https://router.vuejs.org/zh/guide/advanced/meta.html) 属性 `requiresCamera` 的路由：

```ts
/**
 * 全局解析守卫
 */
router.beforeResolve((to,from) => {
    console.log("全局解析守卫");
})
```

`router.beforeResolve` 是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置。

### 全局后置钩子

> **全局后置钩子在路由跳转完成后触发，**然而和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身，因为在这里路由已经跳转完成。
>
> 它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。

```ts
/**
 * 全局后置钩子
 */
router.afterEach((to,from) => {
    console.log("全局后置导航守卫");
})
```

## 路由独享守卫

在确定进行路由跳转，进入到路由中时触发：

你可以直接在路由配置上定义 `beforeEnter` 守卫：

```TS
const routes = [
  {
    path: '/users/:id',
    component: UserDetails,
    beforeEnter: (to, from) => {
      // reject the navigation
      return false
    },
  },
]
```

​	`beforeEnter` 守卫 **只在进入路由时触发**，不会在 `params`、`query` 或 `hash` 改变时触发。例如，从 `/users/2` 进入到 `/users/3` 或者从 `/users/2#info` 进入到 `/users/2#projects`。它们只有在 **从一个不同的** 路由导航时，才会被触发。



## 组件路由守卫

你可以为路由组件添加以下路由守卫：

- `beforeRouteEnter`：在渲染该组件的对应路由被验证前调用
- `beforeRouteUpdate`：在当前路由改变，但是该组件被复用时调用
- `beforeRouteLeave`：在导航离开渲染该组件的对应路由时调用

```ts
const UserDetails = {
  template: `...`,
  beforeRouteEnter(to, from) {
    // 在渲染该组件的对应路由被验证前调用
    // 不能获取组件实例 `this` ！
    // 因为当守卫执行时，组件实例还没被创建！
  },
  beforeRouteUpdate(to, from) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
    // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
  },
  beforeRouteLeave(to, from) {
    // 在导航离开渲染该组件的对应路由时调用
    // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
  },
}
```

`beforeRouteEnter` 守卫 **不能** 访问 `this`，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。

不过，你可以通过传一个回调给 `next` 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：



