

# bena基于注解实现

### 1、什么是注解

- 注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)
- 使用注解，注解作用在类上面，方法上面，属性上面
- 使用注解目的：简化 xml 配置

### 2、设置组件扫描

> 通过组件扫描，可以不必在Spring的配置文件中配置各个`<bean>`，只需要配置好扫描哪些包（package），这些包下的类都将被Spring进行管理，等效于在Spring的配置文件中为这些包下的类都配置了`<bean id=?? class=??>`。

1. 首先要引入`context`命名空间

2. 然后配置组件扫描

   1. 可以通过 context:exclude-filter： 设置哪些内容不进行扫描

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:context="http://www.springframework.org/schema/context"//context命名空间
          xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
               http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
   
       <!--
           1.配置context命名空间：  
               xmlns:context="http://www.springframework.org/schema/context"
               http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
           2.配置组件扫描：
               如果扫描多个包，多个包使用逗号隔开
       -->
       <context:component-scan base-package="day01,day02"/>
   </beans>
   ```

- *开始组件扫描后，就相当于给扫描包下面的所有的类都配置了xml bean*

### 3、Spring 针对 Bean 管理提供的注解

- **实例化Bean注解：**  

  | 注解          | 说明                              |
  | ------------- | --------------------------------- |
  | *@Component*  | 使用在类上用于实例化Bean          |
  | *@Controller* | 使用在web层类上用于实例化Bean     |
  | *@Service*    | 使用在service层类上用于实例化Bean |
  | *@Repository* | 使用在dao层类上用于实例化Bean     |

- **依赖注入注解：**

  | 注解         | 说明                                                         |
  | ------------ | ------------------------------------------------------------ |
  | *@Autowired* | 使用在字段上用于根据*类型*依赖注入                           |
  | *@Qualifier* | 需要结合`@Autowired` 一起使用，根据名称注入。                |
  | *@Resource*  | 相当于上面的结合，如果不指定名称则根据类型注入，如果指定名称则根据名称注入 |
  | *@Value*     | 注入普通属性                                                 |

- **扫描组件注解：**

  | 注解           | 说明                               |
  | -------------- | ---------------------------------- |
  | @Configuration | 作为配置类，替代 xml 配置文件      |
  | @ComponentScan | 相当于 base-package 来设置扫描的包 |

- **其他注解：**

  | 注解             | 说明                                     |
  | ---------------- | ---------------------------------------- |
  | *@Scope*         | 标注Bean的作用范围                       |
  | *@PostConstruct* | 使用在方法上标注该方法是Bean的初始化方法 |
  | *@PreDestroy*    | 使用在方法上标注该方法是Bean的销毁方法   |
  

​	*注意：在使用注解的时候需要导入 spring-aop这个jar包才能使用注解*



### 4、实例化Bean注解使用

> `@Component、@Controller、@Service、@Repository` 的作用是一样的，都是用来实例化bean实例，只不过为了区分模块，做的语义化。他们的实际作用和效果是完全一样。

- 他们都可以直接使用，或者是指定一个id标识。如果是直接使用，则默认使用类名第一个小写作为id标识

```java
@Repository  //如果不写，则默认是类名第一个字母小写 如 Emp => emp
@Repository(value = "emp") //指定id标识
public class Emp {
    Dept dept;
    String ename;
}
```

### 5、依赖注入

- @Autowired： 根据类型注入

- @Qualifier：需要结合@Autowired 一起使用，根据名称注入。

- @Resource： 相当于上面的结合，如果不指定名称则根据类型注入，如果指定名称则根据名称注入

- @Value： 注入普遍属性

  ```java
  @Repository
  public class Emp {
      //1. @Autowired:根据类型注入
      @Autowired
      Dept dept1;
      //2. @Qualifier: 根据名称注入（需要结合@Autowired一起）
      @Autowired
      @Qualifier(value = "dept")
      Dept dept;
      //3. @Resource: 不指定名称则，根据类型 ，指定则根据指定的名称
      @Resource
      @Resource(name = "dept")
      Dept dept2;
  
      //注入普遍属性
      @Value("测试")
      String ename;
  }
  ```

### 6、完全注解开发

> 创建配置类，来替代 xml 配置文件

1. *创建一个配置类，替代xml配置文件*

   ```java
   @Configuration  //作为配置类，替代 xml 配置文件
   @ComponentScan(basePackages = {"day01","day02"}) //相当于 base-package 来设置扫描的包
   public class SpringConfig {
   
   }
   ```

2. *使用：*

   ```java
   @Test
   public void test01() {
       //通过反射加载配置类
       ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
       Emp emp = context.getBean("emp", Emp.class);
       System.out.println(emp.getDept1());
   }
   ```
