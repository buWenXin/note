# 对象的类型---接口

> TypeScript 中的接口是一个非常灵活的概念，除了可用于*对类的一部分行为进行抽象*以外，也常用于对对象的定义，描述。
>
> 在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。定义的接口都要首字母大写

## 1.简单的例子:

- 注意：变量的形状必须和接口的形状保持一致，不能多一个属性也不能少一个属性

```typescript
//定义一个对象
interface Person {
   name: string;
   age: number;
}
//创建对象
let tom: Person = {
    name: 'Tom',
    age：20
};
```

## 2.可选属性

> 有时我们希望不要完全匹配一个形状，那么可以用可选属性：通过`?`来定义一个可选属性，
>
> `?`代表这个变量可以有也可以没有。

```ts
interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom'
};
```

## 3.任意属性

> 通过`[propName: string]: any;` 来定义任意属性，
>
> *注意*：如果接口中定义了任意属性，那么接口中的*其他属性的类型就必须和任意属性的类型一致*，或者是*任意属性类型的子类*

```ts
interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};
```

- 上面的例子：定义任意属性的类型是`any`，所有不会报错。
- 下面的例子：任意属性的类型是`string`，`age`的类型和任意类型不一致导致报错

```ts
//这个接口会报错，因为定义的任意属性的类型是string，但确定属性的类型不是string
interface User {
   name: string,
   age: number,//报错，和任意属性的类型不一致

   [propName: string]: string
}
```

- 任意属性的类型也可以使用联合类型
- 如果同时存在任意属性、可选属性，那么任意属性的数据类型要带undefined

```ts
interface User {
   name: string,
   age: number,

   [propName: string]: string|number
}
```

## 4.只读属性

> 有时候我们希望对象中的一些*字段只能在创建的时候被赋值*，那么可以用 `readonly` 定义只读属性：
>
> 使用了 `readonly`的属性，只能在创建对象的时候赋值！

```java
interface Person {
   readonly name: string;//只读属性
   age: number;
}

let tom: Person = {
   name: "tom",
   age: 18
}
tom.name = "to2";//修改只读属性的值会报错！
```

