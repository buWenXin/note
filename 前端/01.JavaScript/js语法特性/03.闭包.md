

# JavaScript-闭包解读

> 闭包是由于作用域嵌套产生的，内层作用域沿着作用域链查找变量，产生了闭包。（注意，使用全局作用域的变量不会产生闭包）
>
> 闭包的作用在于扩展了作用域中变量的使用范围，使的底层作用域可以去使用外层作用域的变量。
>
> 闭包的存在是因为有作用域链，内层作用域沿着作用域链查找变量，产生了闭包。
>
> 闭包可以分为*块级闭包*和*函数闭包*。



代码块闭包：

```js
{
   let a = 10;

   function Add() {
      a++;
      console.log(a);
   }

   Add(); //产生了闭包 
}
```

嵌套函数闭包：

```js
function f1() {
   let b = 10;

   function add() {
      b++;
      console.log(b);
   }

   add();
}

f1()
```

​	上面的例子都产生了闭包，在函数内部都使用了外层作用域中的变量。

## 闭包

例子1：

```js
function f1() {
   let a = 10;

   function add() {
      a++;
      console.log(a);
   }

   add();
}

f1(); //11
f1(); //11
f1(); //11
```

例子2：

```js
let add;

function f1() {
   let a = 10;

   add = function () {
      a++;
      console.log(a);
   }

   add();
}

f1();  //11
add(); //12
add(); //13
add(); //14
```

​	上面两个例子可以明细看出区别，例子1：无论调用多少次都是出11，而例子2则是会叠加结果。这就说明了在例子2中，闭包变量a并没有被销毁，所以才会叠加。

​	是什么原因导致了刚才的结果？

- 例子1一直都是11，这是因为`add()`是在`f1()`内部声明并调用的，要调用`add()`必须经过`fn1`函数，而fn1函数每次都会去从新声明变量`a`的值。
- 而例子2则是在全局中声明的，变量a不会重复去声明，并且`add()`函数的闭包对象也不会去销毁，所有每次执行使用的都是同一个变量。

## 总结：

- 闭包是因为作用域链而存在，因为有了作用域链，内部的作用域才能使用外层作用域的变量，在函数编译的时候，如果有引用外部的变量，那么就会生成一个作用域链的引入，指向外层作用域。
- 闭包是由于作用域链的存在而产生的，底层的作用域使用了外层作用域中的变量，就产生了闭包。
- 注意：使用了全局作用域中的变量不会产生闭包，只有使用了块级作用域、函数作用域中的变量才会产生闭包。
- 闭包分为块级闭包和函数闭包。
- 如果引用闭包变量的函数是存储在全局变量中，那么闭包是不会被垃圾回收器回收，因为函数对象还存在于全局，函数有作用域链指向闭包变量。



