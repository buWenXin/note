# 操作和访问数据库

- 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。

- 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：
  - *Statement*：用于执行静态 SQL 语句并返回它所生成结果的对象。 （*不建议使用*）
  - *PrepatedStatement*：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。
  - *CallableStatement：*用于执行 SQL 存储过程



### 1.使用Statement操作数据

- 通过调用 `Connection` 对象的 `createStatement()` 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。

- Statement 接口中定义了下列方法用于执行 SQL 语句：

```sql
int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE
ResultSet executeQuery(String sql)：执行查询操作SELECT
```

- 示例：

  ```java
   @Test
      public  void  test01() throws Exception{
          //1.加载MySQL配置文件
          InputStream resourceAsStream = Connect.class.getClassLoader().getResourceAsStream("jdbc.properties");
          //2.读取配置信息  通过Properties类来读取配置文件
          Properties pros = new Properties();
          pros.load(resourceAsStream);
          String user = pros.getProperty("user");
          String password = pros.getProperty("password");
          String url = pros.getProperty("url");
          String driverClass = pros.getProperty("driverClass");
  
          //3.加载驱动
          Class.forName(driverClass);
          //4.获取连接
          Connection connection = DriverManager.getConnection(url, user, password);
          //5.创建statement对象
          Statement statement = connection.createStatement();
          //6.执行查询操作
          ResultSet resultSet = statement.executeQuery("select * from user");
          //7.获取结果集的元数据
          ResultSetMetaData metaData = resultSet.getMetaData();
          // 8.获取结果集的列数
          int columnCount = metaData.getColumnCount();
      }
  ```

- 尽量避免使用`Statement`来操作数据库，因为会带来sql注入的危险 使用 PrepatedStatement 替代

### PrepatedStatement的使用

- **使用PreparedStatement实现增、删、改操作**

```java
@Test
public void test01() throws Exception {
    //1.加载MySQL配置文件
    InputStream rs = Contios01.class.getClassLoader().getResourceAsStream("db.properties");
    Properties pros = new Properties();
    pros.load(rs);
    String user = pros.getProperty("user");
    String password = pros.getProperty("password");
    String url = pros.getProperty("url");
    String driverClass = pros.getProperty("driverClass");

    //2.加载驱动
    Class.forName(driverClass);

    //3.获取连接
    Connection con = DriverManager.getConnection(url, user, password);

    //预编译sql
    PreparedStatement ps = con.prepareStatement("INSERT INTO `status` (`name`,create_time) VALUES(?,?)");
    //填充占位符 ?
    ps.setString(1,"小");
    ps.setDate(2,new Date(new java.util.Date().getTime()));
    //执行sql语句
    ps.execute();
}
```

- **使用使用PreparedStatement实现查询操作**

  ```java
  @Test
  public void test01() throws Exception {
      //1.加载MySQL配置文件
      InputStream rs = Contios01.class.getClassLoader().getResourceAsStream("db.properties");
      Properties pros = new Properties();
      pros.load(rs);
      String user = pros.getProperty("user");
      String password = pros.getProperty("password");
      String url = pros.getProperty("url");
      String driverClass = pros.getProperty("driverClass");
  
      //2.加载驱动
      Class.forName(driverClass);
  
      //3.获取连接
      Connection con = DriverManager.getConnection(url, user, password);
  
      //4.预编译sql
      PreparedStatement ps = con.prepareStatement("SELECT * FROM `order`");
      //5.执行sql查询
      ResultSet resultSet = ps.executeQuery();
      //6.获取ResultSetMetaData
      ResultSetMetaData metaData = resultSet.getMetaData();
      //7.获取列的总数
      int columnCount = metaData.getColumnCount();
  
      //8.通过反射，把查询结果映射到对象中
      ArrayList<Order> orders = new ArrayList<>();
      Class<Order> orderClass = Order.class;
      while (resultSet.next()) {// resultSet.next(): 获取下一条查询记录，如果没有了则返回false
          Order order = orderClass.newInstance();
          for (int i = 0; i < columnCount; i++) {
              String columnName = metaData.getColumnName(i + 1);//获取字段名称
              Object object = resultSet.getObject(i + 1);//获取值
              //使用反射，设置对象的值
              Field field = orderClass.getDeclaredField(columnName);//通过反射获取属性
              field.setAccessible(true);
              field.set(order,object);
          }
          orders.add(order);//添加中数组中
      }
      System.out.println(orders);
  }
  ```

### ResultSet与ResultSetMetaData

- **ResultSet**

  > ResultSet中存储了执行sql语句返回的数据，在ResultSet中定义了next()方法，通过调用它可以获取下一条数据

  - ResultSet 对象维护了一个指向当前数据行的**游标**，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。

  - 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。

    - 例如: getInt(1), getString("name")
    - *注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。*

  - **ResultSet 接口的常用方法：**

    | 方法          | 说明                                              |
    | ------------- | ------------------------------------------------- |
    | next()        | 获取下一条记录的数据，如果没有数据了，则返回fasle |
    | getxxx(index) | index,列的位置，想要获取那个一个列的数据          |
    |               |                                                   |

    

- **ResultSetMetaData**

  > 存储了数据的描述，如列的名称，数据类型，类的总数等等

### 3.6 JDBC API小结

- 两种思想

  - 面向接口编程的思想

  - ORM思想(object relational mapping)
    - 一个数据表对应一个java类
    - 表中的一条记录对应java类的一个对象
    - 表中的一个字段对应java类的一个属性

  > sql是需要结合列名和表的属性名来写。注意起别名。

- 两种技术

  - JDBC结果集的元数据：ResultSetMetaData
    - 获取列数：getColumnCount()
    - 获取列的别名：getColumnLabel()
  - 通过反射，创建指定类的对象，获取指定的属性并赋值
  
- 通过`prepareStatement`来操作数据库，返回值为`ResultSet`

  - `prepareStatement`中会预编译sql语句，然后再填充占位符，最后进行调用执行接口里面【 你、、
  - 、、、

  

- 通过`ResultSet`类来操作返回的数据

  - 在`ResultSet`中存储了从sql查询返回的数据，里面有一个next()方法，通过调用它来获取下一条记录
  - 通过`ResultSet..getMetaData()`来获取`ResultSetMetaData`对象，对象中存储了数据的描述，如列的名称，数据类型，类的总数等等
  - 
