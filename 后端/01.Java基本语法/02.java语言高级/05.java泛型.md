





#### 泛型

>  泛型就是在定义类、接口、方法的时候指定某一种特定类型（碗），让类、接口、方法的使用者来决定具体用哪一种类型的参数（盛的东西） **泛型就是标签,用来占位表明**
>
> 使用泛型的主要优点是能够在编译时进行类型检查,避免报错

- 自定义泛型和使用自定义泛型
  - 自定义泛型类  语法: class MyClass<T>{}
  - 自定义泛型方法 语法:   public <T>  返回值  genericMethod1(T t){}: 范围权限修饰符 泛型 返回值 方法名称 (泛型)
  - 自定义泛型接口 语法:interface  MyTer<T>{}

```java
/*
   1.自定义泛型
       1.自定义泛型类
           语法: class MyClass<T>{}
       2.自定义泛型接口
           语法:interface  MyTer<T>{}
       3.自定义泛型方法
           语法:   public <T> void genericMethod1(T t){}
   3.通配符的使用  泛型通配符: ?
      语法: list<?> 通过?号来表示任意类型
 */

/**
 * 1.自定义泛型类
 */
class Gennitc<T> {
    private T data;

    public T getData() {
        return data;
    }

    public void setData(T t) {
        this.data = t;
    }
}

/**
 * 2.自定义泛型方法
 */
class Proson {
    public <T> T getValue(T t) {
        return t;
    }
    
    public <T> ArrayList<T> getList(T t) {
        ArrayList<T> ts = new ArrayList<>();
        ts.add(t);
        return ts;
    }
}

/**
 * 3.自定义泛型接口
 */

interface GeninceInter<T> {
    T getValue(T t);
    ArrayList<T> getList(T t);
}
/**
 * 使用泛型接口
 *
 */
class GenShix<T> implements GeninceInter<T> {
    @Override
    public T getValue(T t) {
        return t;
    }
    @Override
    public ArrayList<T> getList(T t) {
        ArrayList<T> ts = new ArrayList<>();
        ts.add(t);
        return ts;
    }
}


public class FanXin {
    @Test
    public void test1() {
        //1.使用泛型类
        Gennitc<String> stringGennitc = new Gennitc<>();
        stringGennitc.setData("stting");
        System.out.println(stringGennitc.getData());
        //2.使用泛型方法
        Proson proson = new Proson();
        ArrayList<String> string = proson.getList("string");
        System.out.println(string);
    }
}

```



