

# JavaScript-闭包解读

> 闭包是一个对象，每一个函数内部都会有一个闭包对象。这个闭包对象的作用是，存储函数内部使用外层作用域中的变量。（*不包括全局作用域*）（注意这里的存储不是复制变量的属性，而是使用指针）
>
> 基本类型的数据存储在栈内存中，而对象类型的数据存储在堆内存中。
>
> 注意：如果函数使用了全局变量，是不会被闭包对象所存储的。只有使用了*函数作用域，块级作用域中*的变量才会被闭包对象存储。



代码块闭包：

```js
{
   let a = 10;

   function Add() {
      a++;
      console.log(a);
   }

   Add(); //产生了闭包 
}
```

嵌套函数闭包：

```js
function f1() {
   let b = 10;

   function add() {
      b++;
      console.log(b);
   }

   add();
}

f1()
```

​	上面的例子都产生了闭包，在函数内部都使用了外层作用域中的变量。





## 闭包

例子1：

```js
function f1() {
   let a = 10;

   function add() {
      a++;
      console.log(a);
   }

   add();
}

f1(); //11
f1(); //11
f1(); //11
```

例子2：

```js
let add;

function f1() {
   let a = 10;

   add = function () {
      a++;
      console.log(a);
   }

   add();
}

f1();  //11
add(); //12
add(); //13
add(); //14
```







## 闭包的区别

例子1：

```js
function fn1() {
   let age = 10;

   function AddAge() {
      age++;
      console.log(age);
   }

   AddAge();
}

fn1();//11
fn1();//11
fn1();//11
```

例子2：

```ts
function fn2() {
   let age = 10;

   return function () {
      console.log(this);
      age++;
      console.log(age);
   }

}

let c = fn2();
c();//11
c();//12
c();//13
```

​	上面的两个例子都产生了闭包，区别在于*例子1*中的age不会叠加，无论调用多少次都是11，但是*例子2*中的闭包变量age会叠加！这就说明了在例子2中，闭包变量age并没有被销毁。

是什么原因导致这个结果？

- 例子1为什么每次都是输出11？：
  - 这是因为每次调用`fn1`都会从新给age变量赋值为10





- 原因是：例子1的的函数对象被销毁了，而例子2的函数对象没有被销毁。（闭包对象存储于函数对象中，函数对象被销毁，它也会被销毁）
- 例子1：函数对象被销毁了，每次调用都会创建一个新的函数对象，函数对象又会创建一个新的闭包对象。
- 例子2：函数对象没有被销毁，每次调用的都是同一个函数对象，使用的也是同一个闭包对象。



- 例子1只有`fn1`函数中的`AddAge`这个变量指向函数对象，但是当`fn1`函数指向完成后，`fn1`的执行上下文对象就会从执行栈中移除



