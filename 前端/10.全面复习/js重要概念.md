





## 作用域和作用域链

作用域用来描述 变量的作用范围。

作用域有三种：

- 全局作用域：
  - 在全局中声明的变量（即在window对象中）,在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。只要页面关闭，才会被销毁
- 函数作用域：
  - 在函数内部声明的变量或函数，只能在函数内部去访问或者使用，并且在函数执行完成后就会销毁。
- 块级作用域：
  - ES6中新增的，使用 `let` 和`const`在{}内声明的变量就是块级作用域：



**词法作用域：**

​	词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，在编写代码的时候就已经确定了，不会再变动。

​	根据代码的结构关系来确定作用域。词法作用域是一种静态的词法结构，[Java](http://c.biancheng.net/java/)Script 解析器主要根据词法结构确定每个变量的可见性和有效区域。

例子：

```ts
let name: string = "cat";

function getName() {
   let name: string = "tom";

   return function get() {
      console.log(name);
   }
}

const get = getName();
get()
```

​	上面的代码中，函数的内部返回了一个函数，并且返回的函数中使用到了外部函数中的变量name，那么我们获取到这个函数再去调用的时候，获取到的依然是函数中的`name`属性。

​	**由此可以确定，作用域是静态的，是由函数声明的位置来决定的，不会随着函数的调用发生变化。**

上面的例子中还产生了闭包。



**作用域链:**

​	作用域链是查找变量的链条，用来确定作用域之间嵌套的关系，指导js如何去查找变量，作用域链一样是静态的，在写代码的时候就已经确定了，不会变化。

​	作用域链是一条向上查找的链条，如果一个变量在自身作用域中没有找到，则会沿着作用域链向上查找。作用域链的终点的全局作用域，如果在全局的作用域中还是没有找到，则返回undefined

```js
function getName() {
   return function get() {
      console.log(name);
   }
}

const get = getName();
get()//输出 undefined
```

​	上面的例子，我们去访问一个变量，首先会在自身的作用域中查找，没有找到，如何就会沿着作用域链一路向上查找，最后到终点全局作用域，还是没有找到，则返回undefined



**总结：**

- 作用域是用来描述变量的作用范围的，js中的作用域是静态的，是根据代码的结构关系来确定作用域
- 作用域链用来查找变量的，作用域链描述的是作用域的嵌套关系，js的解析器，会根据作用域链去查找变量。
- 作用域的规则是：里面的可以访问外面的变量，但是外面不能访问里面的变量。可以认为作用域是一种向上查找的规则。



## this 的指向

**普通的函数：this总是指向它的直接调用者，所以普通函数的this是动态的。**

```ts
function User() {
   this.name = "tom";
   this.age = 20;
   this.getage = function () {
      console.log(this);
   }
}

const user = new User();
user.getage() //this指向user对象，因为是user调用它

let get = user.getage;
get() //指向window对象，在全局中是window调用它
```

​	上面的例子中，`user.getage()` 指向的时候，是user对象调用它，所以`this`指向`user`对象，然后我们创建了一个全局变量，将getage这个方法赋值给它，然后进行调用，此时调用者是window对象。



**箭头函数中的this，则不会指向于它的调用者，而是指向于它上层作用域的this**。作用域是静态的不会变，所以箭头函数中的this也是静态的，不会改变。

```js
function User() {
   this.name = "tom";
   this.age = 20;
   this.getage = () => {
      console.log(this);
   }
}

const user = new User();
user.getage() //this 指向user

let get = user.getage;
get()//this 指向user
```

​	上面的例子中：我们使用箭头函数创建了一个匿名函数，并赋值给`getage`。通过user对象去调用时，this指向`user`对象，通过全局对象去调用时，依然指向user对象。无论是谁调用，箭头函数的this都是指向于它上层作用域中的this。



**总结：**

- 普通函数的this，指向于它的直接调用者，并且是动态的，this随着调用者的改变而改变。
- 箭头函数的this，指向于它上层作用域中的this，作用域是静态的不会发生变化，因此箭头函数的this也是静态的。



## js代码的执行过程

- JavaScript 脚本的运行由两个阶段组成：**预编译阶段** 和 **执行阶段**，先进行预编译，再执行语句；



1. 浏览器会先通过预编译器去解析js代码，生成全局执行上下文对象，然后将执行上下文对象推入到执行栈中
2. 执行器会从执行栈中去获取执行上下文对象，然后去执行。
3. 在代码执行阶段，如果遇到函数，则会调用预编译器去解析函数，生成函数执行上下文对象，并推入到执行栈中去执行。
4. 函数执行完毕后，会将函数的执行上下文对象从执行栈中移除。





## 执行上下文和执行栈

**执行上下文：**

> JavaScript 代码是按顺序从上到下被解析的，当然 JavaScript 引擎并非逐行的分析和执行代码，而是逐段的去分析和执行。当执行一段代码时，都会进行预编译，创建这段代码的执行上下文。
>
> **执行上下文是一个对象，是一个用来描述当前代码运行环境的对象**。它是在代码的*预编译阶段创建的*，用来指导执行器如何执行代码。
>
> 执行上下文分为：全局执行上下文和函数执行上下文。
>
> 执行上下文中存储了：函数对象，函数中声明的变量，函数this的指向，函数的作用域链等信息。
>
> 注意：函数对象还存在于变量中，所以函数对象不会随着执行上下文一起被销毁。

```ts
function fn1() {
   let name = 'tom';
   console.log(name);
}

fn1();//执行到这里，发现是要执行一个函数，就会启动编译器对这个函数进行预编译
```

上面的代码的执行的过程是：

- 执行到 fn1()的时候，发现是要执行一个函数，就会启动编译器对这个函数进行预编译
- 在进行预编译的时候,会创建一个属于这个*函数的执行上下文对象*。
- 编译器会将这个函数的 *函数对象、 this、作用域链等信息*存入到这个执行上下文对象中去，然后将这个执行上下文对象push到*函数执行栈中去执行*。



**执行栈：**

> 执行栈又叫*函数执行栈*，它是一种*后进先出*的数据结构，所以的函数的执行上下文都会被push进到这个执行栈中执行。

```js
<script>
   function fn1() {
      let name = 'tom';
      console.log(name);
      fn2();
   }

   function fn2() {
      console.log("我是fn2");
   }

   fn1();
</script>
```



1. 当浏览器在代执行JavaScript代码的时候，会先去预编译全局代码，创建全局执行上下文对象，然后将全局执行上下文对象推入到执行栈中执行。
2. 全局执行上下文对象推入到执行栈中，js的执行器开始执行代码，在执行到11行的时候，发现要执行的是一个函数`fn1()`
3. 此时就会对使用编译器对这个函数进行预编译，创建函数执行上下文对象，然后将执行上下文对象推入到执行栈中执行。
4. 在执行`fn1`函数的时候，又发现要执行一个函数，重复上面的步骤：预编译函数，推入到执行栈中执行。
5. 执行`fn2`函数，当fn2执行完毕后，就会将fn2的执行上下文对象从执行栈中移除销毁。（出栈）
6. `fn2`出栈后会回来继续执行`fn1`，`fn1`执行完成后，将fn1出栈销毁。
7. 最后所以代码执行完毕，此时执行栈中就只剩下了全局执行上下文对象。
8. 全局执行上下文在代码执行完毕后并不好出栈，而是只有当页面销毁的时候才会出栈销毁。



**预编译做了什么：**

- 确定this的指向
- 函数提升 变量提升
- 确定作用域链











- 执行上下文对象是一个用来描述记录代码执行环境的对象。
- 执行栈，是一个类型于数组的数据结果，不过执行栈是后进先出的结构，执行栈里面存储的元素就是执行上下文对象。

## 闭包

> 闭包是一种现象，它是由于嵌套函数，内层的函数调用了外层函数作用域中的变量所产生的。

闭包产生的条件：

​	**嵌套函数，内层的函数调用了外层函数作用域中的变量**

```js
function fn1() {
   debugger
   let age = 10;

   function AddAge() {
      debugger
      age++;
      console.log(age);
   }

   AddAge();
}

fn1();
```

​	上面的例子中就产生了闭包：嵌套函数，并且AddAge这个函数使用了它外层函数fn1函数作用域中的变量。



**闭包的区别：**

例子1：

```js
function fn1() {
   let age = 10;

   function AddAge() {
      age++;
      console.log(age);
   }

   AddAge();
}

fn1();//11
fn1();//11
fn1();//11
```

例子2：

```ts
function fn1() {
   let age = 10;

   return function () {
      console.log(this);
      age++;
      console.log(age);
   }

}

let c = fn1();
c();//11
c();//12
c();//13
```









- 闭包的产生条件：
  - 函数嵌套，内部的函数使用了外层函数作用域中的变量。
- 闭包的作用：
  - 闭包让你可以在一个内层函数中访问到其外层函数的作用域
- 闭包的区别：
  - 闭包也是有区别的，

**不会产生闭包的例子**

```js
function fn1() {
   let age = 10;

   function getage() {
      age++;
      console.log(age);
   }

   getage();
}

fn1();//11
fn1();//11
fn1();//11
fn1();//11
```

​	不会产生闭包是因为，只是单纯的函数嵌套，*内层函数还是在它定义的地方使用*，所以不会产生闭包。

​	这个例子其实短暂产生了闭包，但是在函数调用完毕后又销毁了。



**会产生闭包的例子：**

```js
function fn1() {
   let age = 10;

   return () => {
      age++;
      console.log(age);
   };
}

const c = fn1();
c();//11
c();//12
c();//13
c();//14
```

​	产生了闭包，两个条件都符号了。

## 原型和原型链



## js异步



## New 一个对象的时候做了什么



## JS缓存

- sessionStorage:会话缓存,在页面关闭后就消失
- localStorage:永久缓存,一直存储,触发主动清除
